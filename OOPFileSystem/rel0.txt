***************************
Tema : Relatório 1        *
						  *
Nome : ILLYA Gerasymchuk  *
Número : 78134 			  *
Grupo : 137				  *
***************************

---------------------------
Subclasse Para "Super User"
---------------------------
Na minha implementação decidi não usar uma subclasse para o Super User, dado que a caraterística que o destingue dum outro utilizador é o seu
username ("root"), o qual eu tenho garantia de que é único num sistema de ficheiros. Uma subclasse específica não me parace trazer grandes
benefícios de verificação das premissões, pois eu decidi implementar um método diferenete, a breve descrição do qual vem a seguir.

----------------------------------------------
FileSystemCommad / Verificação das Permissões
----------------------------------------------
A implementação do enumerador "FileSystemCommand" é provavelmente a decisão menos óbvia do projeto. O que eu decidi fazer com isto, é separar os
comandos em grupos:
 * USER_ADMINISTRATION - criar/remover utilizadores
 * ENTITY_READ - ler ficheiros/diretóeiros
 * USER_READ - ler utilizadores (usado para imprimir a lista de utilizadores)
 * ENTITY_WRITE - escrever num focheiro / diretório
 * DIRECTORY_NAVIGATION - mudar de diretório
No FileSystem separei esses comandos em 3 categorias (3 arrays): públicos (todos podem os fazer), privados (só utilizadores que logged in, 
que sejam o "owner" da entidade em questão o podem fazer) e root (operações que SÓ o root pode fazer). O root pode fazer as 3 (públicas, 
privadas e root) e outros utilizadores só as públicas ( e privadas, caso sejam o "owner" da entidade em questão). As arrays são inicializadas
algo semelhante a isto:

	FileSystemCommand[] publicCommands = {FileSystemCommand.ENTITY_READ, FileSystemCommand.DIRECTORY_NAVIGATION, FileSystemCommand.USER_READ}; // anyone can perform them
	FileSystemCommand[] privateCommands = {FileSystemCommand.ENTITY_WRITE}; // only owner can perform them
	FileSystemCommand[] rootCommands = {FileSystemCommand.USER_ADMINISTRATION}; // only root can perform them
	
A decisão de em qual categoria fica o comado é tomada nas funções que respondem aos comandos no "FileSystemManager" e depois são passadas
como argumento para os comandos correspondentes do "FileSystem".

Existem duas variantes da função checkPermissions(): uma que recebe um FileSystemEntitiy e outra que não. A primeira é usada quando é necessário
verificar se um utilizador tem permissão para escrever num ficheiro/diretório, a outra é para casos quando a operação pretendida não
involve entidades do sistema de ficheiros de forma direta (exemplo: ap premissão listar utilizadores não depende dos diretórios/ficheiros).
Na classe "FileSystem" existem duas funções privadas "checkPrivatePermissions()" e "checkRootPermissions()" que são helpers das funções
checkPermissions() (razão pela qual são privadas). Estas existem apenas para o checkPermissions() poder distribuir os pedidos que lhe são feitos,
diminuindo a quantidade de código desta função. Não faz sentido estas duas funções serem públicas, pois só têm sentido no contexto do FileSystem
(não devem ser usadas por entidades exteriores).

------------
PrivacyMode
------------
O segundo enumerador presente é o "PrivacyMode", que simplesmenete indica se uma entidade do sistema de ficheiros é pública ou privada.


São os métodos do "FileSystemManager" que irão ser chamados no "textui", reincaminhando os pedidos de seguida para a(s) correspondente(s)
funçõe(s) do "FileSystem", com os argumentos apropriados.


-------------------
Directory Children
-------------------
Os diretórios têm 2 ou mais filhos (ficheiros ou outros diretórios). Decidi não destinguir o diretório pai doutros (ou seja, em variável
separada), ficando este juntamente com os outros nos "children". Um diretório tem pelo menos 2 children, por cause do pai (..) e o próprio
diretório (.) . 